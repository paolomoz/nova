import { Hono } from 'hono';
import type { Env, SessionData } from '../lib/types.js';
import { generateDesign, bootstrapSite, tokensToCss } from '../lib/ai/design-generator.js';
import { GitHubRepoClient } from '../services/github.js';

const design = new Hono<{ Bindings: Env; Variables: { session: SessionData } }>();

/** POST /api/design/:projectId/generate — AI design generation */
design.post('/:projectId/generate', async (c) => {
  const projectId = c.req.param('projectId');
  const { intent } = await c.req.json<{ intent: string }>();

  if (!intent) return c.json({ error: 'intent required' }, 400);

  // Load brand profile
  const bp = await c.env.DB.prepare(
    'SELECT voice, visual, content_rules, design_tokens FROM brand_profiles WHERE project_id = ? LIMIT 1',
  ).bind(projectId).first();

  const brandProfile = bp ? {
    voice: JSON.parse((bp.voice as string) || '{}'),
    visual: JSON.parse((bp.visual as string) || '{}'),
    contentRules: JSON.parse((bp.content_rules as string) || '{}'),
    designTokens: JSON.parse((bp.design_tokens as string) || '{}'),
  } : null;

  const existingTokens = brandProfile?.designTokens || null;

  const result = await generateDesign(intent, brandProfile, existingTokens, {
    ANTHROPIC_API_KEY: c.env.ANTHROPIC_API_KEY,
  });

  // Save tokens to brand profile
  await c.env.DB.prepare(
    `INSERT INTO brand_profiles (id, project_id, name, design_tokens)
     VALUES (?, ?, 'default', ?)
     ON CONFLICT(project_id, name) DO UPDATE SET
       design_tokens = excluded.design_tokens, updated_at = datetime('now')`,
  ).bind(crypto.randomUUID(), projectId, JSON.stringify(result.tokens)).run();

  return c.json({ ok: true, design: result });
});

/** POST /api/design/:projectId/bootstrap — generate full site from description */
design.post('/:projectId/bootstrap', async (c) => {
  const projectId = c.req.param('projectId');
  const { description } = await c.req.json<{ description: string }>();

  if (!description) return c.json({ error: 'description required' }, 400);

  const bp = await c.env.DB.prepare(
    'SELECT voice, visual, content_rules FROM brand_profiles WHERE project_id = ? LIMIT 1',
  ).bind(projectId).first();
  const brandProfile = bp ? {
    voice: JSON.parse((bp.voice as string) || '{}'),
    visual: JSON.parse((bp.visual as string) || '{}'),
    contentRules: JSON.parse((bp.content_rules as string) || '{}'),
  } : null;

  const result = await bootstrapSite(description, brandProfile, {
    ANTHROPIC_API_KEY: c.env.ANTHROPIC_API_KEY,
  });

  // Save design tokens
  await c.env.DB.prepare(
    `INSERT INTO brand_profiles (id, project_id, name, design_tokens)
     VALUES (?, ?, 'default', ?)
     ON CONFLICT(project_id, name) DO UPDATE SET
       design_tokens = excluded.design_tokens, updated_at = datetime('now')`,
  ).bind(crypto.randomUUID(), projectId, JSON.stringify(result.design.tokens)).run();

  return c.json({ ok: true, design: result.design, pages: result.pages });
});

/** POST /api/design/:projectId/commit — commit CSS to GitHub */
design.post('/:projectId/commit', async (c) => {
  const projectId = c.req.param('projectId');

  const project = await c.env.DB.prepare(
    'SELECT github_org, github_repo FROM projects WHERE id = ?',
  ).bind(projectId).first<{ github_org: string; github_repo: string }>();

  if (!project?.github_org || !project?.github_repo) {
    return c.json({ error: 'No GitHub repository configured' }, 400);
  }

  // Get design tokens
  const bp = await c.env.DB.prepare(
    'SELECT design_tokens FROM brand_profiles WHERE project_id = ? AND name = ?',
  ).bind(projectId, 'default').first<{ design_tokens: string }>();

  if (!bp?.design_tokens) return c.json({ error: 'No design tokens to commit' }, 400);

  const tokens = JSON.parse(bp.design_tokens);
  const css = tokensToCss(tokens);

  const github = new GitHubRepoClient(c.env.GITHUB_TOKEN);
  const branchName = `nova/design-${Date.now()}`;

  await github.createBranch(project.github_org, project.github_repo, branchName);

  const commit = await github.commitFiles(
    project.github_org, project.github_repo, branchName,
    [{ path: 'styles/design-tokens.css', content: css }],
    'feat(design): update design tokens\n\nGenerated by Nova AI design pipeline',
  );

  const pr = await github.createPR(
    project.github_org, project.github_repo,
    branchName, 'main',
    'Update design tokens',
    `## Design Token Update\n\nGenerated by Nova AI design pipeline.`,
  );

  return c.json({ ok: true, commit: { sha: commit.sha }, pr: { number: pr.number, url: pr.htmlUrl } });
});

/** GET /api/design/:projectId/tokens — get current design tokens */
design.get('/:projectId/tokens', async (c) => {
  const bp = await c.env.DB.prepare(
    'SELECT design_tokens FROM brand_profiles WHERE project_id = ? AND name = ?',
  ).bind(c.req.param('projectId'), 'default').first<{ design_tokens: string }>();

  if (!bp?.design_tokens) return c.json({ tokens: null });

  return c.json({ tokens: JSON.parse(bp.design_tokens) });
});

/** PUT /api/design/:projectId/tokens — manually update design tokens */
design.put('/:projectId/tokens', async (c) => {
  const projectId = c.req.param('projectId');
  const { tokens } = await c.req.json<{ tokens: Record<string, unknown> }>();

  await c.env.DB.prepare(
    `INSERT INTO brand_profiles (id, project_id, name, design_tokens)
     VALUES (?, ?, 'default', ?)
     ON CONFLICT(project_id, name) DO UPDATE SET
       design_tokens = excluded.design_tokens, updated_at = datetime('now')`,
  ).bind(crypto.randomUUID(), projectId, JSON.stringify(tokens)).run();

  return c.json({ ok: true });
});

/** POST /api/design/:projectId/theme — generate theme variant */
design.post('/:projectId/theme', async (c) => {
  const projectId = c.req.param('projectId');
  const { variant } = await c.req.json<{ variant: string }>();

  if (!variant) return c.json({ error: 'variant required' }, 400);

  const bp = await c.env.DB.prepare(
    'SELECT design_tokens FROM brand_profiles WHERE project_id = ? AND name = ?',
  ).bind(projectId, 'default').first<{ design_tokens: string }>();

  if (!bp?.design_tokens) return c.json({ error: 'No base design tokens' }, 400);

  const result = await generateDesign(
    `Create a "${variant}" theme variation (e.g. seasonal, dark mode, high-contrast) of the existing design`,
    null,
    JSON.parse(bp.design_tokens),
    { ANTHROPIC_API_KEY: c.env.ANTHROPIC_API_KEY },
  );

  return c.json({ ok: true, theme: result });
});

export default design;
